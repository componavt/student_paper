\chapter{Угадыватель чисел}
\label{ch:guessnumbers}

\section{Аннотация} 

Эта глава посвящена программе «Угадыватель чисел»~\cite{PanfilovaApp}, идея которой взята из книги Л. Ф. Магницкого, «Арифметика»~\cite{Galanin}. Вначале дается описание задачи, затем рассказывается о процессе создания приложения. раскрываются такие темы, как работа с экранами, создание процедур и обработка ошибок.


\section{Описание задачи}

Суть предлагаемой нами задачи описана в книге Л. Ф. Магницкого, «Арифметика», в главе: «Об утешных некиих действиях, через арифметику употребляемы»~\cite{Galanin}.

Пронумеруем дни недели от одного (понедельник) до семи (воскресенье). Для начала предложим игроку загадать число, равное номеру любого дня недели. Далее попросим загадавшего выполнить следующие действия:
\begin{enumerate}
\item Умножить номер загаданного дня недели на два.
\item К полученному произведению прибавить пять.
\item Затем полученную сумму умножить на пять.
\item Полученное число умножить на десять.
\item Назвать результат вычислений.
\end{enumerate}

Таким образом, с помощью этих арифметических преобразований мы легко сможем определить какое число загадал игрок.

\section{Решение задачи}

Раскроем секрет математического фокуса. Чтобы перейти от полученного числа к загаданному, необходимо вычесть из него двести пятьдесят и поделить полученное число на сто. Таким образом, мы получим число, в котором номер дня недели – число сотен в числе. Рассмотрим доказательство решения задачи. Пусть $ a $ — искомое число (день недели). Выполним указанные действия над числом $ a $:

\begin{enumerate}
   \item $2\cdot a $

   \item $2\cdot a + 5$

   \item $5\cdot(2 \cdot a  + 5) = 10 a + 25$
 
   \item $(10a + 25)\cdot 10 = 100  a + 250$
 
   \item  $\frac{100  a + 250 - 250}{100} =  a $
\end{enumerate}

Доказательство выполнено, и мы получили число $  a $.

\begin{mdfstyle}[nobreak=true,frametitle=Вопрос]
  \sloppy   
  В доказательстве алгоритма говорится, что ($  a $ — это искомое число, но не уточняется, какое это число. Определите вид числа и его допустимые значения, приведите примеры.  Ответ на странице ... todo.
  \label{question:text}
\end{mdfstyle}

\section{Реализация приложения}
\label{styles}
В программе «Угадыватель чисел» (The Numbers Guessing Game)~\cite{PanfilovaApp} загаданный игроком номер дня недели это то, что мы будем искать.
Создадим глобальную переменную  \textbf{secretNumber} для хранения числа, загаданного игроком. Присвоим переменной значение равное нулю. Так как оно не входит в интервал от одного до семи, переменная изначально не будет хранить в себе число, которое мог бы загадать пользователь. Также
отметим, что объекты имемнуются с помощью стиля СamelCase \footnote[][-0cm]{\index{Процедуры и переменные!Именование} \emph{Именовать объекты} 
можно также произвольно, но рекомендуется использовать один из общепринятых стилей.
}\marginnote[0.2cm]{
Список самых распространённых стилей см. на с.~\pageref{answer:naming}.
}. 
\subsection{Определение числа загаданного игроком}
Чтобы не допустить ввод буквенных значений в поле для ввода загаданного числа (\textit{numberText}), необходимо установить у него свойство \textit{Только числа} \textit{(NumbersOnly}). Рассмотрим блок обработки нажатия (см. рис.~\ref{fig:block:button:click}) на кнопку «Узнать ответ» (Button1).
Когда игрок нажимает на эту кнопку, последовательно выполняются следующие действия:
\begin{enumerate}
  \item Вызываетcя процедура \textbf{visibleFalseImages} (см. рис. ~\ref{fig:block:visible:false:images}), которая устанавливает свойство Visible у всех изображений с цифрами в ложь (false). Таким образом, пока не будет определено число загаданное пользователем, изображения с цифрами не будут отображаться.
  \begin{figure}
    \includegraphics{./graphics/programs/guess_numbers/block_Button1Click_AppInventor_2018.png}
      \caption[Блок обработки нажатия на кнопку Button1.][6pt]{Блок обработки нажатия на кнопку Button1}
    \label{fig:block:button:click}
  \end{figure}

  \item Вызываетcя процедура \textbf{visibleFalseImages} (см. рис. ~\ref{fig:block:visible:false:images}), которая устанавливает свойство Visible у всех изображений с цифрами в ложь (false). Таким образом, пока не будет определено число загаданное пользователем, изображения с цифрами не будут отображаться.
  \begin{figure}
    \includegraphics{./graphics/programs/guess_numbers/procedure_visibleFalseImages_AppInventor_2018.png}
      \caption[Процедура visibleFalseImages.][6pt]{Процедура visibleFalseImages устанавливает свойство Visible у всех изображений с цифрами в ложь (false).}
    \label{fig:block:visible:false:images}
  \end{figure}

  \item Устанавливается свойство \textit{Видимость} (\textit{Visible}) в значение правда (true) у изображения со знаком вопроса (Image8).
  \item Если значение поля для ввода загаданного числа (numberText) пусто, то устанавливается красный цвет шрифта у поля ErrorLabel (сообщение «Пожалуйста, введите полученное число.»), иначе последовательно выполняются следующие шаги:
  \begin{itemize}
    \item Устанавливается белый цвет шрифта у поля \textit{ErrorLabel}.
    \item Производится подсчёт значения переменной \textit{secretNumber}:
    \item Вызывается процедура \textbf{selectVisibleImage}, которая будет рассмотрена далее.
  \end{itemize}
\end{enumerate}
Возникает вопрос: почему для того, чтобы отображать сообщение об ошибке мы меняем цвет текста у поля \textit{ErrorLabel}, а не управляем значением свойства \textit{Видимость} (\textit{Visible})? Дело в том, что при использовании свойства \textit{Visible} любое изменение его значения вызовет перерисовку экрана, а элементы будут менять свои позиций. Для создания эффекта «статичного» экрана был применён описанный ранее приём. Таким образом, если цвет поля белый, то компонент \textit{ErrorLabel} сливается с фоном экрана, как будто исчезая.
\section{Процедура selectVisibleImage}

\begin{figure}
  \includegraphics{./graphics/programs/guess_numbers/procedure_selectVisibleImage_AppInventor_2018.png}
    \caption[Процедура selectVisibleImage.][6pt]{Процедура selectVisibleImage управляет отображением изображений с цифрами.}
  \label{fig:block:click:select:visible:image}
\end{figure}

Процедура \textbf{selectVisibleImage} (см. рисунок ~\ref{fig:block:click:select:visible:image}) определяет изображение с какой цифрой необходимо показать игроку.
В случае, если число не было определено, показывается изображение с вопросительным знаком (\textit{Image8}).

Рассмотрим пример. Допустим, игрок загадал число три. На основании введенного пользователем числа в поле \textit{numberText} на экране \textit{FinalScreen} (в данном случае должно быть введено число 550) приложение считает и записывает новое значение переменной \textit{secretNumber}, равное трем. Процедура ставит в соответствие значению переменной \textit{secretNumber} изображение с определенной цифрой и показывает его пользователю. 
В нашем примере это изображение числа три (\textit{Image3}). Если переменная number содержит в себе значение, не входящее в интервал от одного до семи, то будет показано изображение со знаком вопроса (\textit{Image8}), а текст надписи \textit{ErrorСalculating} станет видимым («Допущена ошибка в расчетах. Попробуйте снова.»).

Важно отметить, что перед выполнением условий сравнения переменной \textit{secretNumber} с введенным пользователем числом, выполняется установка свойства \textit{Видимый} (\textit{Visible}) в \textit{ложь} (\textit{false}) у элементов Image8 и ErrorСalculating.
Тем самым мы отмечаем отсутствие ошибок в вычислениях и заранее убираем с экрана знак вопроса, предполагая, что на его месте будет изображением с определенной цифрой. Если же переменная secretNumber не входит в интервал от одного до семи, то у элементов \textit{Image8} и \textit{ErrorСalculating} устанавливается значение свойства \textit{Видимый} (\textit{Visible}) в \textit{правда} (\textit{true}), 
так приложение сообщает пользователю о его ошибке(ах) в вычислениях.

\subsection{Работа с экранами}
При проектировании приложения были учтены рекомендации из официальной документации \textit{App Inventor} по ограничению количества экранов во избежание проблем с переполнением памяти.
Поэтому в игре используется восемь экранов (рекомендуемое количество — меньше 10)~\cite{MitManyScreens}:
\begin{enumerate}
\item \textbf{Screen1} — главный экран приложения представляющий из себя меню игры.
\item \textbf{About} — экран, содержащий основную информацию о приложении.
\item \textbf{Step1}, \textbf{Step2}, \textbf{Step3}, \textbf{Step4}, \textbf{Step5} — экраны с описанием действий, которые необходимо выполнить пользователю, чтобы приложение смогло угадать загаданное число. На экранах есть следующие кнопки для навигации между экранами приложения:
\begin{itemize}
  \item \textit{На шаг назад} (\textit{previousStepButton}) перемещает игрока на предыдущий экран.
  \item \textit{Далее} (\textit{nextStepButton}) перемещает игрока на следующий экран.
  \item \textit{В главное меню} (\textit{backToMainMenuButton}) возвращает игрока на главный экран Screen1.
\end{itemize}
\item \textbf{FinalScreen} — экран, на котором заканчивается игра. Здесь пользователю необходимо ввести получившееся в результате вычислений число и нажать кнопку \textit{Узнать ответ}, чтобы приложение вывело на экран загаданное игроком число.
\end{enumerate}

\begin{mdfstyle}[nobreak=true,frametitle=Задание]
  \sloppy   
  Приложение можно перепроектировать таким образом, чтобы экраны \textit{Step1}, \textit{Step2}, \textit{Step3}, \textit{Step4}, \textit{Step5} представляли собой один экран. Попробуйте реализовать приложение «Угадыватель чисел» с одним общим экраном \textit{Steps}, который будет при нажатии на нём кнопок навигации последовательно показывать пользователю действия, которые ему необходимо выполнить с загаданным числом.]
  Если вызывать функцию \textit{открыть другой экран} (\textit{open another screen}), а затем не вызывать функцию закрыть экран (\textit{close screen}), то через некоторое время приложение израсходует всю доступную память.
  \end{mdfstyle}

Рассмотрим решение этой проблемы на примере экрана \textit{Screen1}, который содержит в себе название игры и две кнопки: \textit{Старт} (\textit{startButton} для перехода на экран \textit{Steps} и \textit{Об игре} (\textit{AboutButton} для перехода на экран \textit{About}.

Для того, чтобы не получить ошибку переполнения памяти, создадим процедуру для закрытия экрана, которую назовём \textbf{closeScreen} (см. рис ~\ref{fig:block:click:close:screen}). Она будет содержать в себе один единственный блок управления \textit{«закрыть экран»} (\textit{close screen}). 
\begin{figure}
  \includegraphics[width=100,height=100]{./graphics/programs/guess_numbers/procedure_closeScreen_AppInventor_2018.png}
    \caption[Процедура closeScreen.][6pt]{Процедура closeScreen закрывает текущий экран.}
  \label{fig:block:click:close:screen}
\end{figure}
Возникает вопрос: зачем действие по закрытию экрана помещать в отдельную процедуру? Это необходимо для того, чтобы последовательно выполнить функции \textit{«открыть другой экран»} и \textit{«закрыть экран»} при возникновении события нажатия на некоторую кнопку (\textit{Click}). Из-за особенностей \textit{App Inventor} соединить функцию закрытия и открытия в любом блоке управления вместе не получится, поэтому способ, описанный выше, решает эту проблему.

\newthought{The front matter} of a book refers to all of the material that
comes before the main text.  The following table from shows a list of
material that appears in the front matter of \VDQI, \EI, \VE, and \BE
along with its page number.  Page numbers that appear in parentheses refer
to folios that do not have a printed page number (but they are still
counted in the page number sequence).
